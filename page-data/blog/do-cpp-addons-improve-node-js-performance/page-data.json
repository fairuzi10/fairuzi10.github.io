{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/do-cpp-addons-improve-node-js-performance/","result":{"data":{"post":{"html":"<p>Do you know that you could code C++ and use it in your Node Application? What are the benefits? Does it make you application faster? Is it worth it to do? <strong>No, it isnâ€™t.</strong> Donâ€™t get me wrong, let me explain ðŸ˜„.</p>\n<h2>C++ Addons</h2>\n<blockquote>\n<p>Node.js Addons are dynamically-linked shared objects, written in C++, that can be loaded into Node.js using the require() function, and used just as if they were an ordinary Node.js module.</p>\n</blockquote>\n<p>So basically, you could code C++ with Node addons framework (I prefer <a href=\"https://github.com/nodejs/nan\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">nan</a> for compability reasons) like the following</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;nan.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Method</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Nan<span class=\"token operator\">::</span>FunctionCallbackInfo<span class=\"token operator\">&lt;</span>v8<span class=\"token operator\">::</span>Value<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  info<span class=\"token punctuation\">.</span><span class=\"token function\">GetReturnValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Set</span><span class=\"token punctuation\">(</span>Nan<span class=\"token operator\">::</span><span class=\"token function\">New</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ToLocalChecked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Init</span><span class=\"token punctuation\">(</span>v8<span class=\"token operator\">::</span>Local<span class=\"token operator\">&lt;</span>v8<span class=\"token operator\">::</span>Object<span class=\"token operator\">></span> exports<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  exports<span class=\"token operator\">-></span><span class=\"token function\">Set</span><span class=\"token punctuation\">(</span>Nan<span class=\"token operator\">::</span><span class=\"token function\">New</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ToLocalChecked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n               Nan<span class=\"token operator\">::</span>New<span class=\"token operator\">&lt;</span>v8<span class=\"token operator\">::</span>FunctionTemplate<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>Method<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token function\">GetFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">NODE_MODULE</span><span class=\"token punctuation\">(</span>hello<span class=\"token punctuation\">,</span> Init<span class=\"token punctuation\">)</span></code></pre></div>\n<p>And use it in your Node application</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> addon <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bindings\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>addon<span class=\"token punctuation\">.</span><span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 'world'</span></code></pre></div>\n<p>So why bother leaving the beautiful, interpreted, high-level world of Javascript and go into the dark, compiled, and low-level world of C++? I thought it must be for performance. Come on, who doesnâ€™t know that C++ is one of the fastest language around? So I decided to give it a shot in hope that I would make super-fast code and can publish it in NPM like our fellow cool JS boys do every seconds. So what is the result? Letâ€™s jump right into the benchmark. Anyway, all codes are available <a href=\"https://github.com/fairuzi10/node-addons-benchmark\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">in my Github</a> and the data is in <a href=\"https://docs.google.com/spreadsheets/d/15oy6BME_C3uDi9Y_-8E_NRg-Sm36LTynSsseFsULGP0/edit?usp=sharing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Google Spreadsheets</a>.</p>\n<h2>Matrix Exponentiation</h2>\n<p>For the first experiment, instead of the boring prime-generator-or-so problem, letâ€™s just try matrix exponentiation. For the sake of simplicity, letâ€™s use naive matrix multiplication in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> but with <a href=\"https://en.wikipedia.org/wiki/Modular_exponentiation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">modular exponentiation</a> result in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>3</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^3logP)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span> algorithm. Before we go to the exponentation, letâ€™s do some benchmarking for just multiplication.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/fff80/multiplication.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABF0lEQVQoz5VS2Y7DMAj0/39qE5/4wvGx4zhNV9q20vKADJphACNKKUopY4zW2p+mTnPOSSnXe9s2eIQAj18meu+11hX0Pn3rw6dK5GIINfiUEio+AZctqAAzxoi4tXb77yGKRG65DHH3cGYv/ykEFz6VYUKbyhiDiFASLdz+bXgKV5+ajfMxyf9SdrEFfuUFiuScV/k51aU0tZYUkOiXS0WrMU/B/ux/bnt9wCU1nlJjbb4D73nYgEITA6mW0+EJNLFoNXONqXNOFKwmp0ntTu60P6xVSBFrVbRKUjK5Qo5DAEucO2wlxGhtZzabMtKqXevHjk+22wPQZA05h4FwOeU4MrO/yV/sOI57Z3/tDfl1Q+dZjM/kH/rCwg+3Y3hcAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on Matrix Multiplication\"\n        title=\"C++ vs. Node JS on Matrix Multiplication\"\n        src=\"/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/fff80/multiplication.png\"\n        srcset=\"/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/c649e/multiplication.png 163w,\n/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/3a76f/multiplication.png 325w,\n/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/fff80/multiplication.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>As we could see, C++ addon beats plain Javascript implementation by around 380%. Now itâ€™s time for exponentiation, letâ€™s put <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">N = 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span> to make things simple (who likes multi-variable function?).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9d856122750dbfbbfea6e26feb6f1b4c/fff80/exponentiation.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABCElEQVQoz5WSi3LEIAhF/f9vzcsXogLpNem2yW6mM2WYzBG5iAbXWpvnedu2dV3TYYBlWbz3iAOwnKYJgCV294s5PQxkcBsh0T0ViTFSzpITEV019rIh7oed8WNLP8BQ/RT8wGlODkMSd6NqxMptL21AqZbZQlafNZDBL2C1KdoWruIJechWYjnFmQX61nHa88lgp9KXUFtHk9hAouxo+AaoL981XmAiQ4xtnKn2+x5v8EfQ4VdVZuOiheBC+Q0egwN6c6jRYqze15RqjBwDvld4DHIIvdYhHv9KVNRiytvmu+KdZF5WKgXXSZkwKEiAA7BEZsOd0fZ1YsaU3G8l5wiYPSbcxf+0L5BIwTB94c5lAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on Matrix Exponentiation\"\n        title=\"C++ vs. Node JS on Matrix Exponentiation\"\n        src=\"/static/9d856122750dbfbbfea6e26feb6f1b4c/fff80/exponentiation.png\"\n        srcset=\"/static/9d856122750dbfbbfea6e26feb6f1b4c/c649e/exponentiation.png 163w,\n/static/9d856122750dbfbbfea6e26feb6f1b4c/3a76f/exponentiation.png 325w,\n/static/9d856122750dbfbbfea6e26feb6f1b4c/fff80/exponentiation.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>We got a nice logarithmic graph here. Itâ€™s 430% improvement, better than the previous one. Remember that you could go to <a href=\"https://docs.google.com/spreadsheets/d/15oy6BME_C3uDi9Y_-8E_NRg-Sm36LTynSsseFsULGP0/edit?usp=sharing#gid=109010642\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the spreadsheet</a> to go through the details.</p>\n<h2>String Matching</h2>\n<p>Letâ€™s see another problem we could code using C++ Addons. To make things more interesting, letâ€™s play with something we havenâ€™t tried before, string. Given two string, count the number of occurrence of the second string in the first one. One could solve this problem in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NM)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> but there are faster algorithms too, one of which is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N + M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> rolling hash algorithm. Letâ€™s use this one.</p>\n<p>To test it, I decided to put <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi><mo>=</mo><mfrac><mi>N</mi><mn>10</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">M = \\frac{N}{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.217331em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> and because the complexity is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N + M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>, it should not affecting the improvement percentage too much for whatever value I put into M. This is what I got.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3983aa4973c96bb5413aa90caf3c82cf/fff80/matching.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABJ0lEQVQoz5VSCW4DIQzc/z80UrLLsdwY7O0AiZRUVdWOkOWDsc2IjYi01tZaY0yYgIPMeZ5IKqX2fdcTInJ9YmPm3vsKVpHlCrkH71OMPYacMzqO6icGubVWax0c5pVdzo/hsrMPDzLGYvO/kMGZa0qucsZO7Q/kMUSEGqfK4Lg0HITf18Z9nN7nEBlk6oz3g2NDy+BQx425Ab8LJjP7fA/osbBLErJgDiRcCj3tEHUKhrG5lFUgvhJdNnEoksprcbQqucXAOfUUhw2BrBGiDTSidmq/P05zOG98NoaMrkYVrYpSWanqXfGOgoeFTzlBJrQd5FrIaX/cbvZ+d/tDPe4hxuM4vPdmYoRKhZSUMc4PoAqxtutX4MbTW99L5Hr7Z9urJNf/8QWGsMAukJWSVwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on String Matching\"\n        title=\"C++ vs. Node JS on String Matching\"\n        src=\"/static/3983aa4973c96bb5413aa90caf3c82cf/fff80/matching.png\"\n        srcset=\"/static/3983aa4973c96bb5413aa90caf3c82cf/c649e/matching.png 163w,\n/static/3983aa4973c96bb5413aa90caf3c82cf/3a76f/matching.png 325w,\n/static/3983aa4973c96bb5413aa90caf3c82cf/fff80/matching.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>We got 350% improvement here. Not differed too much compared to our previous benchmark. But if you look closely to <a href=\"https://github.com/fairuzi10/node-addons-benchmark/blob/master/matching/matching.js#L50\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the code</a>, you should notice that my Javascript implementation is not exactly the same as my C++ addon implementation. It turns out that Javascript is quite slow at building string, so I need to made a few modifications to speed up the process. Donâ€™t worry, I only count the time needed to run <code class=\"language-text\">countOccurrence</code> so it wouldnâ€™t affect the result.</p>\n<p>Facing that string problem, I think itâ€™s a good idea to try buffer which is well-known for its speed. Not only for C++ addon, I try it for the pure Javascript too. Here is the result.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7097dbab6139d8adad9ea6f99e272bd2/fff80/matching-buffer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABX0lEQVQoz41R607GIAzd+z+h0cToN/3YBTYGlGspdkMTfxj1bGva0tNTuiHnvG2b1nrfd3eBQ6XUcRyclFKu69ozHLLlDFPahaEyENmDRNZaAECA4ME6qNnEAMZY4DAH7z0XsCVqdGEopaSUmMxNeqo7P4bdtpNbT2VE7GP8SWbONSWFRAdgLvQ3mV3+ckGfKnOMrz7WjHQqfx+b6/nFil2DaRmri3h40lBDbplJPAKxoOGGwzUJ9pH6fdgptUEk48mFyoK1JkLXKFDeqWyUNRXLLQaWjTH21WNtsTQDxXteuKvpoKQoyerWYld0soCtISRrtFpyigNzUk6zFK/jy/v4NN0flXjU8/MunhbxPE2jELdZTbOal22ZpOBKeSgNJmM5yTHFRd5vrw/i/TaLcby/LYce50kbs19wAFIptmrfDf9r6zap+LJD+xW8zk/vXMdlz6ebNnwdfUO7Tv6BDw82urBnQdeIAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on String Matching with Buffer\"\n        title=\"C++ vs. Node JS on String Matching with Buffer\"\n        src=\"/static/7097dbab6139d8adad9ea6f99e272bd2/fff80/matching-buffer.png\"\n        srcset=\"/static/7097dbab6139d8adad9ea6f99e272bd2/c649e/matching-buffer.png 163w,\n/static/7097dbab6139d8adad9ea6f99e272bd2/3a76f/matching-buffer.png 325w,\n/static/7097dbab6139d8adad9ea6f99e272bd2/fff80/matching-buffer.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Comparing C++ addon + buffer with Javascript + buffer, we got 300% improvement which is less than the previous one which might confirm my suspicion about slow Javascriptâ€™s string performance. If we compare C++ addon + buffer with Javascript without buffer, we got 550% improvement in total.</p>\n<h2>Set</h2>\n<p>OK, we already have 2 classic problems, but what about builtin data structure? Letâ€™s give <code class=\"language-text\">Set</code> a try. In Javascript, <code class=\"language-text\">Set</code> actually <a href=\"https://codereview.chromium.org/220293002/#ps1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">implements hash table</a> so weâ€™ll compare it with <a href=\"https://github.com/fairuzi10/node-addons-benchmark/blob/master/set/schema.cc#L13\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">C++ unordered_set</a>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e80491e4c000f02e51d4798ee207d922/fff80/set.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABKklEQVQoz5VS2W7EMAj0/3/otloljm3wCdgltrJH1arqPDgwEQyXaa1Za4+JEAIi2gm1t21bvHPuwYjIuGBkYjzRpQ/MDBBSjJJiylkzPn9fOINVuZSilqZY7DK+uXyRGn4KTD3zmvLV+NHVt1FPtTuUxsPUWmOMyhLRaoGZH+8UO41UGLMcQFgk02Dpfytreqw9lIGlE0+SaJSksxjMRgVVXGnVmgGztTFiFR8FMqcQOSVGkODrYQlBXULsGqzlafw1xlGoeyjeJXTYvBfwKtJzFhV4rW6t6pwzUfKw391224/PDe1BEVpEmmhzGG3ZbX3PYjXRGUy1RRfutw/vva7XHhZj2nYLAOeJWIsAeh667X3f9VRguprCjHfMpp/u6ug3mMesRx//xRfCm8BMBDxPngAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on Set (Hash Table)\"\n        title=\"C++ vs. Node JS on Set (Hash Table)\"\n        src=\"/static/e80491e4c000f02e51d4798ee207d922/fff80/set.png\"\n        srcset=\"/static/e80491e4c000f02e51d4798ee207d922/c649e/set.png 163w,\n/static/e80491e4c000f02e51d4798ee207d922/3a76f/set.png 325w,\n/static/e80491e4c000f02e51d4798ee207d922/fff80/set.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>We got 160% improvement here, the smallest of all our benchmark. If you look carefully in <a href=\"https://docs.google.com/spreadsheets/d/15oy6BME_C3uDi9Y_-8E_NRg-Sm36LTynSsseFsULGP0/edit?usp=sharing#gid=238918653\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the spreadsheet</a> you might notice that in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>1.000.000</mn></mrow><annotation encoding=\"application/x-tex\">N = 1.000.000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>, Javascriptâ€™s Set performance even become the winner, the only case we see pure Javascript win over C++ addon in quite high N. So if you want to use some data structures, youâ€™re good to go with native ES6 data structures.</p>\n<h2>Summary</h2>\n<p>From all the benchmark we have, we could expect C++ addons improve our Node JS app performance around 300% up to 500%. Is it good enough? I donâ€™t think so. With only for a few performance improvements, you need to code in C++, connect it to your Node app, and donâ€™t forget to maintain it. With all these burden, you are better off investing your time optimizing the algorithm you use if performance really matters to you. During this experiment, I also came accross <a href=\"https://nodeaddons.com/streaming-data-from-c-to-node-js/#example---sensor-data\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">a reference</a> that supports my opinion.</p>\n<blockquote>\n<p>Believe it or not, performance isnâ€™t the most common reason we create C++ addons for Node.js.\nPerhaps the most common reason addons are used is their ability to leverage existing C++ code.\nThis can be especially critical when interacting with devices - specifically devices that only provide C/C++ APIâ€™s.</p>\n</blockquote>\n<hr class=\"section-divider\" />\n<p>Before I try the addons, I hope for at least <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>10</mn><mo>Ã—</mo></mrow><annotation encoding=\"application/x-tex\">10\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">Ã—</span></span></span></span> improvement because JS is an interpreted, dynamic-typed language which I thought must be slow. Yes, I look at you, Python. It turns out that Node JS is already fast and even comparable to C++ so we donâ€™t have to struggle code in the hard way just to make sure our code run fast. After all, this experiment was a fun. Itâ€™s interesting to see how fast Node JS is thanks to the great work V8 engine has done. ðŸ˜„</p>","timeToRead":6,"frontmatter":{"title":"Do C++ Addons Improve Node JS Performance? A Benchmark","date":"13 January 2019","description":"Do you know that you could code C++ and use it in your Node Application? What are the benefits? Does it make you application faster? Is it worth it to do? Let the benchmark speaks.","tags":["Knowledge","Coding"],"thumbnail":{"publicURL":"/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/multiplication.png"},"lang":null},"fields":{"slug":"/blog/do-cpp-addons-improve-node-js-performance/"}},"relatedPost":{"edges":[{"node":{"id":"1bf86235-4389-5209-b8fb-a16d674d08a0","fields":{"slug":"/blog/upscale-gojek/"},"frontmatter":{"title":"Gojek Upscale 3.0: Ready to Upscale Yourself?","description":"Want to learn best practices of software engineering from experts in the industry? Gojek Upscale is for you. Find out what will you get by joining this great event."}}},{"node":{"id":"e9b49156-7d57-5121-9b04-28f481ad3b75","fields":{"slug":"/blog/inheritance-tanpa-oop/"},"frontmatter":{"title":"Inheritance Tanpa OOP","description":"Masih berpikir bahwa inheritance hanya dapat dilakukan dengan OOP? Baca pos ini dan ubah pemikiran tersebut."}}}]}},"pageContext":{"slug":"/blog/do-cpp-addons-improve-node-js-performance/","tags":["Knowledge","Coding"]}},"staticQueryHashes":[]}