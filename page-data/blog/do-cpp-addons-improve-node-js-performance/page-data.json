{"componentChunkName":"component---src-templates-blog-post-js","path":"/blog/do-cpp-addons-improve-node-js-performance/","result":{"data":{"post":{"html":"<p>Do you know that you could code C++ and use it in your Node Application? What are the benefits? Does it make you application faster? Is it worth it to do? <strong>No, it isnâ€™t.</strong> Donâ€™t get me wrong, let me explain ðŸ˜„.</p>\n<h2>C++ Addons</h2>\n<blockquote>\n<p>Node.js Addons are dynamically-linked shared objects, written in C++, that can be loaded into Node.js using the require() function, and used just as if they were an ordinary Node.js module.</p>\n</blockquote>\n<p>So basically, you could code C++ with Node addons framework (I prefer <a href=\"https://github.com/nodejs/nan\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">nan</a> for compability reasons) like the following</p>\n<div class=\"gatsby-highlight\" data-language=\"cpp\"><pre class=\"language-cpp\"><code class=\"language-cpp\"><span class=\"token macro property\">#<span class=\"token directive keyword\">include</span> <span class=\"token string\">&lt;nan.h></span></span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Method</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">const</span> Nan<span class=\"token operator\">::</span>FunctionCallbackInfo<span class=\"token operator\">&lt;</span>v8<span class=\"token operator\">::</span>Value<span class=\"token operator\">></span><span class=\"token operator\">&amp;</span> info<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  info<span class=\"token punctuation\">.</span><span class=\"token function\">GetReturnValue</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">Set</span><span class=\"token punctuation\">(</span>Nan<span class=\"token operator\">::</span><span class=\"token function\">New</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"world\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ToLocalChecked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">void</span> <span class=\"token function\">Init</span><span class=\"token punctuation\">(</span>v8<span class=\"token operator\">::</span>Local<span class=\"token operator\">&lt;</span>v8<span class=\"token operator\">::</span>Object<span class=\"token operator\">></span> exports<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  exports<span class=\"token operator\">-></span><span class=\"token function\">Set</span><span class=\"token punctuation\">(</span>Nan<span class=\"token operator\">::</span><span class=\"token function\">New</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">ToLocalChecked</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n               Nan<span class=\"token operator\">::</span>New<span class=\"token operator\">&lt;</span>v8<span class=\"token operator\">::</span>FunctionTemplate<span class=\"token operator\">></span><span class=\"token punctuation\">(</span>Method<span class=\"token punctuation\">)</span><span class=\"token operator\">-></span><span class=\"token function\">GetFunction</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">NODE_MODULE</span><span class=\"token punctuation\">(</span>hello<span class=\"token punctuation\">,</span> Init<span class=\"token punctuation\">)</span></code></pre></div>\n<p>And use it in your Node application</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> addon <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"bindings\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hello\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>addon<span class=\"token punctuation\">.</span><span class=\"token function\">hello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 'world'</span></code></pre></div>\n<p>So why bother leaving the beautiful, interpreted, high-level world of Javascript and go into the dark, compiled, and low-level world of C++? I thought it must be for performance. Come on, who doesnâ€™t know that C++ is one of the fastest language around? So I decided to give it a shot in hope that I would make super-fast code and can publish it in NPM like our fellow cool JS boys do every seconds. So what is the result? Letâ€™s jump right into the benchmark. Anyway, all codes are available <a href=\"https://github.com/fairuzi10/node-addons-benchmark\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">in my Github</a> and the data is in <a href=\"https://docs.google.com/spreadsheets/d/15oy6BME_C3uDi9Y_-8E_NRg-Sm36LTynSsseFsULGP0/edit?usp=sharing\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Google Spreadsheets</a>.</p>\n<h2>Matrix Exponentiation</h2>\n<p>For the first experiment, instead of the boring prime-generator-or-so problem, letâ€™s just try matrix exponentiation. For the sake of simplicity, letâ€™s use naive matrix multiplication in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>3</mn></msup><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^3)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mclose\">)</span></span></span></span> but with <a href=\"https://en.wikipedia.org/wiki/Modular_exponentiation\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">modular exponentiation</a> result in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><msup><mi>N</mi><mn>3</mn></msup><mi>l</mi><mi>o</mi><mi>g</mi><mi>P</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N^3logP)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1.064108em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord\"><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"msupsub\"><span class=\"vlist-t\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.8141079999999999em;\"><span style=\"top:-3.063em;margin-right:0.05em;\"><span class=\"pstrut\" style=\"height:2.7em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\">3</span></span></span></span></span></span></span></span><span class=\"mord mathdefault\" style=\"margin-right:0.01968em;\">l</span><span class=\"mord mathdefault\">o</span><span class=\"mord mathdefault\" style=\"margin-right:0.03588em;\">g</span><span class=\"mord mathdefault\" style=\"margin-right:0.13889em;\">P</span><span class=\"mclose\">)</span></span></span></span> algorithm. Before we go to the exponentation, letâ€™s do some benchmarking for just multiplication.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/fff80/multiplication.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABGElEQVQoz5WS247DIAxE+f9PbcLN5urYZkVI05W2rbTzMMLIwyEOhoiccyEE73065U4BgLV2rbdtc85Za4lo/JJRVWZehep00ZEqI0LJmXOqtaaUng2XVqth5lKKqorI7d/LMbR0aTTMfYdz9/JPpcj0SiNkmWQiQkQRYebb35YnmFOVWOZihv9FhiK5v/aNiLTW1vHzqy7SZC3UGDqGdOKQpbQJ1Of957TXD7hQ44kaa/LaeKQ+YhaR2SOtSatHQiUyK8atc6naW8UcPYJHt4PdcX/E6DBH7N6Rd9XajkAIPWdVNecMhXIpMWrvYXPBRrd7/9g5p7g9CKHGgAAsAgB0HK33dIe/6DiOe2Z/9Sb8ekPnsxifwz/6wsIPgheV+AAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on Matrix Multiplication\"\n        title=\"C++ vs. Node JS on Matrix Multiplication\"\n        src=\"/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/fff80/multiplication.png\"\n        srcset=\"/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/c649e/multiplication.png 163w,\n/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/3a76f/multiplication.png 325w,\n/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/fff80/multiplication.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>As we could see, C++ addon beats plain Javascript implementation by around 380%. Now itâ€™s time for exponentiation, letâ€™s put <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>100</mn></mrow><annotation encoding=\"application/x-tex\">N = 100</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span> to make things simple (who likes multi-variable function?).</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/9d856122750dbfbbfea6e26feb6f1b4c/fff80/exponentiation.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABDElEQVQoz5WS0W7EIAwE+f9vPSAEMGC8dkXSa3N3UaXO02jjJUqwY2bv/bZtMcZyEGMMIaSUvPchhBjj4/EIIXjvSyl2weHAzNRMdUUCK01yzlSr1EJE144+WeV5cObHI3yIAjgLP3Li5MBM+1QaSh2drfGSNrR23StSxU66k15EB8MB0ock0rqmQV3Ocu1CHTwVuH8zAAeZYR88YQZVKMQU9iKAyPcZT1GRVTZF7YD+/o83+SN0zDx6197QCI2E6pvchksmOzPjnEdKo5SRc8/7yPkqt2Hf9znGKq+7Egg0l7ptaQI8xYdIrUGtVAoxTsEUhBhLJYGyCFTddWPWlrx+lZwroHo78Fr+J1+QSMEwNp8NBwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on Matrix Exponentiation\"\n        title=\"C++ vs. Node JS on Matrix Exponentiation\"\n        src=\"/static/9d856122750dbfbbfea6e26feb6f1b4c/fff80/exponentiation.png\"\n        srcset=\"/static/9d856122750dbfbbfea6e26feb6f1b4c/c649e/exponentiation.png 163w,\n/static/9d856122750dbfbbfea6e26feb6f1b4c/3a76f/exponentiation.png 325w,\n/static/9d856122750dbfbbfea6e26feb6f1b4c/fff80/exponentiation.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>We got a nice logarithmic graph here. Itâ€™s 430% improvement, better than the previous one. Remember that you could go to <a href=\"https://docs.google.com/spreadsheets/d/15oy6BME_C3uDi9Y_-8E_NRg-Sm36LTynSsseFsULGP0/edit?usp=sharing#gid=109010642\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the spreadsheet</a> to go through the details.</p>\n<h2>String Matching</h2>\n<p>Letâ€™s see another problem we could code using C++ Addons. To make things more interesting, letâ€™s play with something we havenâ€™t tried before, string. Given two string, count the number of occurrence of the second string in the first one. One could solve this problem in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(NM)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> but there are faster algorithms too, one of which is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N + M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span> rolling hash algorithm. Letâ€™s use this one.</p>\n<p>To test it, I decided to put <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>M</mi><mo>=</mo><mfrac><mi>N</mi><mn>10</mn></mfrac></mrow><annotation encoding=\"application/x-tex\">M = \\frac{N}{10}</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1.217331em;vertical-align:-0.345em;\"></span><span class=\"mord\"><span class=\"mopen nulldelimiter\"></span><span class=\"mfrac\"><span class=\"vlist-t vlist-t2\"><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.872331em;\"><span style=\"top:-2.6550000000000002em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mtight\">1</span><span class=\"mord mtight\">0</span></span></span></span><span style=\"top:-3.23em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"frac-line\" style=\"border-bottom-width:0.04em;\"></span></span><span style=\"top:-3.394em;\"><span class=\"pstrut\" style=\"height:3em;\"></span><span class=\"sizing reset-size6 size3 mtight\"><span class=\"mord mtight\"><span class=\"mord mathdefault mtight\" style=\"margin-right:0.10903em;\">N</span></span></span></span></span><span class=\"vlist-s\">â€‹</span></span><span class=\"vlist-r\"><span class=\"vlist\" style=\"height:0.345em;\"><span></span></span></span></span></span><span class=\"mclose nulldelimiter\"></span></span></span></span></span> and because the complexity is <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>O</mi><mo stretchy=\"false\">(</mo><mi>N</mi><mo>+</mo><mi>M</mi><mo stretchy=\"false\">)</mo></mrow><annotation encoding=\"application/x-tex\">O(N + M)</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.02778em;\">O</span><span class=\"mopen\">(</span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span><span class=\"mbin\">+</span><span class=\"mspace\" style=\"margin-right:0.2222222222222222em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">M</span><span class=\"mclose\">)</span></span></span></span>, it should not affecting the improvement percentage too much for whatever value I put into M. This is what I got.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3983aa4973c96bb5413aa90caf3c82cf/fff80/matching.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABKklEQVQoz5VS2W4DIQzc///QSMkC5jCXsU0Fm0pJVVXpPFg+NHgY+SAi55z3HgBwAwCccyEE77219jxPt6Gq8x2HiDDzVVxD0YmVMaWSM2estSLimr5jkccYvffFEbm6V/JrecX9jiwyMxPRJ+Q5dcvU2jVkpvEBeS1RpSGlS8gcy0poyE/ZIiqizHuJLjKxYOWQ2eOoXYhYRbYCeTVMd/f5H5aZm8SiWLV0EZ2XQ8+4TN2G9d5ra9eAZBaavgg2Le1buLC0OjJKLVzyiojkQYmOOSfRCC6djwAmJkgVgMB1sM3ZZm21tqfYUiRMLcWeItVCRKq6yL1RdMncbv5+j+fDPu6YszEmpQQbq7QWS7EAMS0YY8YYx/wTY4xndp2X6ny5s+N7pPP/+AKGsMAuxzUeqgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on String Matching\"\n        title=\"C++ vs. Node JS on String Matching\"\n        src=\"/static/3983aa4973c96bb5413aa90caf3c82cf/fff80/matching.png\"\n        srcset=\"/static/3983aa4973c96bb5413aa90caf3c82cf/c649e/matching.png 163w,\n/static/3983aa4973c96bb5413aa90caf3c82cf/3a76f/matching.png 325w,\n/static/3983aa4973c96bb5413aa90caf3c82cf/fff80/matching.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>We got 350% improvement here. Not differed too much compared to our previous benchmark. But if you look closely to <a href=\"https://github.com/fairuzi10/node-addons-benchmark/blob/master/matching/matching.js#L50\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the code</a>, you should notice that my Javascript implementation is not exactly the same as my C++ addon implementation. It turns out that Javascript is quite slow at building string, so I need to made a few modifications to speed up the process. Donâ€™t worry, I only count the time needed to run <code class=\"language-text\">countOccurrence</code> so it wouldnâ€™t affect the result.</p>\n<p>Facing that string problem, I think itâ€™s a good idea to try buffer which is well-known for its speed. Not only for C++ addon, I try it for the pure Javascript too. Here is the result.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7097dbab6139d8adad9ea6f99e272bd2/fff80/matching-buffer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABZklEQVQoz42QbW/dIAyF8/9/4dRK1XqzXvICCQFMwPilStikfpjWPUiWsXXkYw+IuG2b937f93SzbZtz7jgO7721dl3XXvHeO+estYioNwMzM5GqQpUYIwAQwJkhJmAM5YQQImSIeOacY4w5ZxGVm6G1VmtVVWbupZ789dujXlq+JhNRt/GtWFVul3JWOYCwyfdikSvBRrnyARQy58JIck3+aptZmIWY+gwRRuJU6MjigU9URBJmFSIMIjjcTqhb6vswc2OFIiFLOjlXZq5CSeUU3KVtgl5aVKGh1lpK6acn1tI0QMsZzpy4HlKdVMtpbXGlZBtEPs8ag3cL1jKoasU6W/M+/vwYX6fnizMvfn7bzeti3qZpNOYxu2l287ItkzWzNfZwHgJSu8SllsU+H+8/zMdjNuP4/LUcfpwnH8J+kwCscwnA7XuIMca0WUdEg/6T1trv7DrHHa/Xgw5/Wl/Qu/MffAIPNrqwJffU9QAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on String Matching with Buffer\"\n        title=\"C++ vs. Node JS on String Matching with Buffer\"\n        src=\"/static/7097dbab6139d8adad9ea6f99e272bd2/fff80/matching-buffer.png\"\n        srcset=\"/static/7097dbab6139d8adad9ea6f99e272bd2/c649e/matching-buffer.png 163w,\n/static/7097dbab6139d8adad9ea6f99e272bd2/3a76f/matching-buffer.png 325w,\n/static/7097dbab6139d8adad9ea6f99e272bd2/fff80/matching-buffer.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>Comparing C++ addon + buffer with Javascript + buffer, we got 300% improvement which is less than the previous one which might confirm my suspicion about slow Javascriptâ€™s string performance. If we compare C++ addon + buffer with Javascript without buffer, we got 550% improvement in total.</p>\n<h2>Set</h2>\n<p>OK, we already have 2 classic problems, but what about builtin data structure? Letâ€™s give <code class=\"language-text\">Set</code> a try. In Javascript, <code class=\"language-text\">Set</code> actually <a href=\"https://codereview.chromium.org/220293002/#ps1\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">implements hash table</a> so weâ€™ll compare it with <a href=\"https://github.com/fairuzi10/node-addons-benchmark/blob/master/set/schema.cc#L13\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">C++ unordered_set</a>.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 600px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/e80491e4c000f02e51d4798ee207d922/fff80/set.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 61.963190184049076%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAIAAADtbgqsAAAACXBIWXMAAAsTAAALEwEAmpwYAAABKElEQVQoz5WS2W7EIAxF+f8PnVYjQgCb1VsVosxStap6HsC+yHgBN+cMIeyLnDMihkXO2Xt/6jHGhyIiduFkYU9U1LAxQK6lSC21NUR8Hl8cwXPO3ruZicipnsY3ly/RTI8EK597vfLV+NFV1Ulah0aUyebGGKUUVSWiswVmfqwr2WHUzthkB8IujYxF/8482XBo7oZdiZdIZL1KLcbsiGiMYarCvAJWa2ZlSCoCjWsuXCsjSE5jD4TAtRKiMjtmJqJrjNZJE/QUK0acKQkkqUVbkzHeqjuf6pgzUU2w3aO/bfunx7BTgVmQFnMNY572PPejWFU9gmnMEvP99pFSAshhD1iq3wIAHF8kBATw3iPitm05Z1guETl7ZzX9dM+OfsM9Zm1q/+ULwpvATFCslcQAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"C++ vs. Node JS on Set (Hash Table)\"\n        title=\"C++ vs. Node JS on Set (Hash Table)\"\n        src=\"/static/e80491e4c000f02e51d4798ee207d922/fff80/set.png\"\n        srcset=\"/static/e80491e4c000f02e51d4798ee207d922/c649e/set.png 163w,\n/static/e80491e4c000f02e51d4798ee207d922/3a76f/set.png 325w,\n/static/e80491e4c000f02e51d4798ee207d922/fff80/set.png 600w\"\n        sizes=\"(max-width: 600px) 100vw, 600px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>We got 160% improvement here, the smallest of all our benchmark. If you look carefully in <a href=\"https://docs.google.com/spreadsheets/d/15oy6BME_C3uDi9Y_-8E_NRg-Sm36LTynSsseFsULGP0/edit?usp=sharing#gid=238918653\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">the spreadsheet</a> you might notice that in <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mi>N</mi><mo>=</mo><mn>1.000.000</mn></mrow><annotation encoding=\"application/x-tex\">N = 1.000.000</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.68333em;vertical-align:0em;\"></span><span class=\"mord mathdefault\" style=\"margin-right:0.10903em;\">N</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span><span class=\"mrel\">=</span><span class=\"mspace\" style=\"margin-right:0.2777777777777778em;\"></span></span><span class=\"base\"><span class=\"strut\" style=\"height:0.64444em;vertical-align:0em;\"></span><span class=\"mord\">1</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">.</span><span class=\"mord\">0</span><span class=\"mord\">0</span><span class=\"mord\">0</span></span></span></span>, Javascriptâ€™s Set performance even become the winner, the only case we see pure Javascript win over C++ addon in quite high N. So if you want to use some data structures, youâ€™re good to go with native ES6 data structures.</p>\n<h2>Summary</h2>\n<p>From all the benchmark we have, we could expect C++ addons improve our Node JS app performance around 300% up to 500%. Is it good enough? I donâ€™t think so. With only for a few performance improvements, you need to code in C++, connect it to your Node app, and donâ€™t forget to maintain it. With all these burden, you are better off investing your time optimizing the algorithm you use if performance really matters to you. During this experiment, I also came accross <a href=\"https://nodeaddons.com/streaming-data-from-c-to-node-js/#example---sensor-data\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">a reference</a> that supports my opinion.</p>\n<blockquote>\n<p>Believe it or not, performance isnâ€™t the most common reason we create C++ addons for Node.js.\nPerhaps the most common reason addons are used is their ability to leverage existing C++ code.\nThis can be especially critical when interacting with devices - specifically devices that only provide C/C++ APIâ€™s.</p>\n</blockquote>\n<hr class=\"section-divider\" />\n<p>Before I try the addons, I hope for at least <span class=\"katex\"><span class=\"katex-mathml\"><math><semantics><mrow><mn>10</mn><mo>Ã—</mo></mrow><annotation encoding=\"application/x-tex\">10\\times</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:0.72777em;vertical-align:-0.08333em;\"></span><span class=\"mord\">1</span><span class=\"mord\">0</span><span class=\"mord\">Ã—</span></span></span></span> improvement because JS is an interpreted, dynamic-typed language which I thought must be slow. Yes, I look at you, Python. It turns out that Node JS is already fast and even comparable to C++ so we donâ€™t have to struggle code in the hard way just to make sure our code run fast. After all, this experiment was a fun. Itâ€™s interesting to see how fast Node JS is thanks to the great work V8 engine has done. ðŸ˜„</p>","timeToRead":6,"frontmatter":{"title":"Do C++ Addons Improve Node JS Performance? A Benchmark","date":"13 January 2019","description":"Do you know that you could code C++ and use it in your Node Application? What are the benefits? Does it make you application faster? Is it worth it to do? Let the benchmark speaks.","tags":["Knowledge","Coding"],"thumbnail":{"publicURL":"/static/08f6f43d3e266dd0f09ca78e7e7bf9cc/multiplication.png"},"lang":null},"fields":{"slug":"/blog/do-cpp-addons-improve-node-js-performance/"}},"relatedPost":{"edges":[{"node":{"id":"12750ce5-d6a3-5a3b-8f61-f7c2817cb49c","fields":{"slug":"/blog/inheritance-tanpa-oop/"},"frontmatter":{"title":"Inheritance Tanpa OOP","description":"Masih berpikir bahwa inheritance hanya dapat dilakukan dengan OOP? Baca pos ini dan ubah pemikiran tersebut."}}},{"node":{"id":"5b01096c-bcbf-50cd-be72-52036a074412","fields":{"slug":"/blog/upscale-gojek/"},"frontmatter":{"title":"Gojek Upscale 3.0: Ready to Upscale Yourself?","description":"Want to learn best practices of software engineering from experts in the industry? Gojek Upscale is for you. Find out what will you get by joining this great event."}}}]}},"pageContext":{"slug":"/blog/do-cpp-addons-improve-node-js-performance/","tags":["Knowledge","Coding"]}},"staticQueryHashes":[]}